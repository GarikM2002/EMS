@page "/login"
@inject AuthService AuthService
@inject NavigationManager Navigation
@inject IJSRuntime jsRuntime

<MudGrid Justify="Justify.Center">
	<MudItem xs="12" md="8">
		<MudPaper Class="pa-4">
			<MudForm @ref="form" @bind-IsValid="@success" @bind-Errors="@errors">
				<MudTextField @bind-Value="model.Email" T="@string" Label="Email" For="@(() => model.Email)"
							  Required="true" RequiredError="Email is required!" />
				<MudTextField @bind-Value="model.Password" T="@string" Label="Password" For="@(() => model.Password)"
							  HelperText="Enter your password" InputType="InputType.Password" Required="true"
							  RequiredError="Password is required!" />
				<MudItem Class="d-flex align-items-center justify-content-between mt-4">
					<MudButton Variant="Variant.Filled" Color="Color.Primary"
							   Disabled="@(!success)" Class="ml-auto" OnClick="OnLogin">
						Login
					</MudButton>
				</MudItem>
			</MudForm>
			@foreach (var e in errors)
			{
				<MudText Color="Color.Error" Class="mt-2">@e</MudText>
			}
		</MudPaper>
	</MudItem>
</MudGrid>

@code {
	MudForm form = null!;
	bool success;
	string[] errors = [];
	LoginViewModel model = new LoginViewModel();

	private async Task OnLogin()
	{
		errors = []; // Clear previous error message
		var response = await AuthService.LoginAsync(model);
		if (response.IsSuccessStatusCode)
		{
			var token = await response.Content.ReadAsStringAsync();
			// Store the token in local storage
			await jsRuntime.InvokeVoidAsync("localStorage.setItem", "authToken", token);
			await jsRuntime.InvokeVoidAsync("alert", token);

			Navigation.NavigateTo("/");
		}
		else
		{
			errors = ["Invalid login attempt. Please check your credentials and try again."];
		}
	}

	private async Task<bool> ValidateForm()
	{
		await form.Validate();
		return success;
	}
}